---
title: "Gestion d'√âv√©nements : R√©pondre aux Actions Utilisateur"
description: "Apprenez √† rendre vos composants interactifs en r√©pondant aux clics, aux saisies clavier et autres √©v√©nements utilisateur en React."
tags: ['react', 'events', 'onclick', 'onchange', 'state', 'beginner', 'interactivity', 'hooks']
estimatedTimeMinutes: 20
objectives:
  - Attacher des gestionnaires d'√©v√©nements (event handlers) aux √©l√©ments JSX (ex: `onClick`).
  - D√©finir des fonctions de gestion d'√©v√©nements dans un composant.
  - Comprendre l'objet √©v√©nement (`e`).
  - G√©rer les √©v√©nements de changement sur les inputs (`onChange`) pour contr√¥ler les formulaires.
  - (Activit√©) Cr√©er un champ de saisie contr√¥l√©.
---

import { InfoTip, CodeBlock, Quiz, ProjectStep, InteractiveCodeEditor } from '@/components/mdx';

# Rendre l'UI Vivante : Gestion des √âv√©nements ! üñ±Ô∏è‚å®Ô∏è

Nos composants savent maintenant *avoir* un √©tat (`useState`), mais comment cet √©tat peut-il **changer** en r√©ponse √† ce que fait l'utilisateur ? Si l'utilisateur **clique** sur un bouton, **tape** dans un champ, ou **survole** un √©l√©ment, nous voulons que notre composant r√©agisse !

C'est le r√¥le de la **gestion d'√©v√©nements** en React. C'est tr√®s similaire √† la fa√ßon dont on le fait en HTML et JavaScript natif, mais avec une syntaxe adapt√©e √† JSX.

## √âcouter les √âv√©nements en JSX

Vous attachez des "√©couteurs d'√©v√©nements" directement comme des props sur vos √©l√©ments JSX. Les noms sont en `camelCase` (comme `onClick`, `onChange`, `onSubmit`, `onMouseEnter`, etc.) et vous leur passez une **fonction** √† ex√©cuter lorsque l'√©v√©nement se produit.

<CodeBlock language="jsx" title="Exemple avec onClick">
'use client'; // N√©cessaire pour les gestionnaires d'√©v√©nements

import { Button } from '@/components/ui/button';

function BoutonAlerte() {
  // 1. D√©finir la fonction √† ex√©cuter
  const handleClick = () => {
    alert("Vous avez cliqu√© !");
  };

  return (
    // 2. Passer la fonction √† l'attribut onClick
    <Button onClick={handleClick}>
      Cliquez-moi
    </Button>
  );
}

// On peut aussi d√©finir la fonction directement "en ligne" (inline)
function AutreBouton() {
  return (
    <Button onClick={() => console.log("Clic en ligne !")}>
      Log Clic
    </Button>
  );
}

export default BoutonAlerte; // Ou un composant parent qui utilise ces boutons
</CodeBlock>

<InfoTip type="warning" title="Fonction, pas Appel !">
Faites attention √† passer la **r√©f√©rence** de la fonction (`handleClick`) et non le **r√©sultat** de son appel (`handleClick()`). Si vous mettez les parenth√®ses, la fonction s'ex√©cutera *imm√©diatement* lors du rendu, pas seulement au clic ! L'exception est si vous utilisez une fonction fl√©ch√©e inline `onClick={() => maFonction(arg)}`, ce qui est correct.
</InfoTip>

## L'Objet √âv√©nement (`e`)

Souvent, la fonction de gestion d'√©v√©nements re√ßoit automatiquement un **objet √©v√©nement** (conventionnellement nomm√© `e` ou `event`) comme premier argument. Cet objet contient des informations sur l'√©v√©nement qui s'est produit.

*   **`e.preventDefault()` :** Tr√®s utile pour les formulaires (`onSubmit`) ou les liens (`onClick` sur `<a>`) pour **emp√™cher le comportement par d√©faut** du navigateur (comme recharger la page lors de la soumission d'un formulaire).
*   **`e.target` :** Fait r√©f√©rence √† l'√©l√©ment DOM sur lequel l'√©v√©nement s'est produit.
*   **`e.target.value` :** Pour les √©l√©ments de formulaire comme `<input>`, `<textarea>`, `<select>`, cela donne la **valeur actuelle** de l'√©l√©ment.
